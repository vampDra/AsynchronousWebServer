### 日志模块(logger.cpp/h)
- 采用单例模式实现日志器，采用宏定义实现日志流式输出。
- 采用状态机实现日志格式解析，并通过logFormatter格式化输出日志。
- 设置有LogAppender基类作为日志输出地，目前有StdOut与File两种继承类，后期可扩展添加设备继承甚至网络继承等等。
- 采用同步写的方式写日志，构建临时LoggerWrap对象构建日志，其析构时调用Logger->log方法。同步写的优势在于程序出错时错误日志会打印出来，不会残存在日志buf中没来得及输出。


### 协程模块(fiber.cpp/h)
协程的本质就是用户态线程，仅有用户栈，切换协程时仅需切换用户栈而无需进内核，所以更加轻量级，切换消耗更少。
- Fiber是对ucontext_t函数簇的封装，协程运行在线程内部，每个线程定义线程主协程，为了避免子协程执行完跑飞，子协程执行结束后仅能与线程主协程进行切换。
- 子协程为有栈协程，栈入口为协程执行函数，主协程无栈协程，仅用来作为子协程切换跳板。


### 协程调度模块(scheduler.cpp/h)
协程调度结构类似线程池处理任务，每次从任务队列中取出协程并执行，若无协程，则阻塞在空闲协程上(idle)。协程调度器会创建N个线程，用来处理M个协程，最后实现N:M的切换。
- 创建Task结构体，可以通过传入协程or函数创建任务，并可以指定具体某个线程执行，可以用来做负载均衡。
- 设置空闲协程与通知函数，当线程无执行任务时，切换至空闲协程，当有新任务到来时，通知函数通知线程使其从空闲协程返回并执行任务。


### IO协程调度(IOManager.cpp/h)
IO协程调度是协程调度的继承类，重写了其空闲协程执行函数(idle)与通知函数，将其与epoll结合起来。
- idle协程的入口函数重写为epoll_wait，所以当无任务时，线程实际阻塞在epoll_wait等待事件发生。
- 有事件触发时，epoll_wait返回，并将发生的事件压入任务队列，随后返回至主协程执行任务。
- 重写通知函数，使用eventfd实现跨线程事件通知，当有新任务添加时，写入eventfd，阻塞在epoll_wait的线程会返回执行任务。


### 定时器模块(timer.cpp/h)
采用单层时间轮实现定时器，结合epoll_wait的超时参数实现毫秒级定时。整体结构类似拉链法的哈希。
时间轮的插入、删除、执行均是O(1)复杂度，效率较高，适合定时任务过多时使用，缺点是精度不太高。
- 时间轮的结构类似处理哈希冲突时的拉链法，在每个槽拉一条链表，代表当前时刻会触发的定时器。
- 新添加的定时器通过超时时间可以计算出散列的位置。
- 在每次时间到期时，时间轮会将所有到期的任务压入协程调度器的任务队列中等待执行。


### hook模块(hook.cpp/h)
hook是编写一组系统同名函数，替代源函数，实现我们想要的效果。hook模块是项目的核心模块，所有的功能几乎全部来源于hook
本部分的hook，采用协程与epoll_wait将socket相关api封装为异步模式，这样上层便能以同步的方式编程，达到异步的性能。
- hook的核心是通过epoll来管理事件触发，配合协程切换实现异步。
- 首先得确认当前fd是否是socket fd,，其实也很简单，只要是通过socket函数与accept、connect函数创建的fd就是socket相关fd，可以通过hook上述三个函数实现记录效果。
- 当socket相关fd调用socket相关函数时，以读为例：内核缓冲区有数据时，直接读取。无数据时，在epoll上注册事件，并设置回调为当前协程，随后协程便可以切换到其他协程执行，当注册事件触发时，会自动切换回来执行。


### Tcp_server模块(Tcp_server.cpp/h)
基础模块实现后，上层模块便简单很多。Tcp_server模块是基类，上层服务器均可以通过继承Tcp_server实现相应的业务。
- Tcp_server核心功能只有一条：监听listen fd，当有新连接时，便分配新协程执行新连接。


### Http_server模块(http_server.cpp/h)
Http_server继承Tcp_server，并使用http_parser进行解析请求，通过http_servlet封装响应报文。
本部分已经属于上层应用，使用者可以自己续写，不再过多介绍。
